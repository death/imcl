// Meta TODO: create table and prioritize

// Small tasks
//
//   Context creation and access
//
// Medium tasks
//
//   Main
//   Parameters stacks (shared)
//   Widgets: Main
//   Widgets: Drags
//   Widgets: Data Plotting
//   Tab Bars, Tabs
//   Drag and Drop
//
// Large tasks
//
//   Windows Utilities
//   Widgets: Input with Keyboard
//   Miscellaneous Utilities
//

// ------------------------------------------------------------------------------------------------------------------------

// Context creation and access

// Each context create its own ImFontAtlas by default. You may
// instance one yourself and pass it to CreateContext() to share a
// font atlas between imgui contexts.  All those functions are not
// reliant on the current context.
IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
IMGUI_API ImGuiContext* GetCurrentContext();
IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert);

// Main

// access the IO structure (mouse/keyboard/gamepad inputs, time,
// various configuration options/flags)
IMGUI_API ImGuiIO&      GetIO();
// access the Style structure (colors, sizes). Always use
// PushStyleCol(), PushStyleVar() to modify style mid-frame.
IMGUI_API ImGuiStyle&   GetStyle();
// start a new Dear ImGui frame, you can submit any command from this
// point until Render()/EndFrame().
IMGUI_API void          NewFrame();
// ends the Dear ImGui frame. automatically called by Render(), you
// likely don't need to call that yourself directly. If you don't need
// to render data (skipping rendering) you may call EndFrame() but
// you'll have wasted CPU already! If you don't need to render, better
// to not create any imgui windows and not call NewFrame() at all!
IMGUI_API void          EndFrame();
// ends the Dear ImGui frame, finalize the draw data. You can get call
// GetDrawData() to obtain it and run your rendering
// function. (Obsolete: this used to call
// io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your
// render function yourself.)
IMGUI_API void          Render();
// valid after Render() and until the next call to NewFrame(). this is
// what you have to render.
IMGUI_API ImDrawData*   GetDrawData();

// Windows Utilities

// "current window" = the window we are appending into while inside a
// Begin()/End() block. "next window" = next window we will Begin()
// into.
// get draw list associated to the current window, to append your own
// drawing primitives
IMGUI_API ImDrawList*   GetWindowDrawList();

// Prefer using SetNextXXX functions (before Begin) rather that SetXXX
// functions (after Begin).
//
// set next window size limits. use -1,-1 on either X/Y axis to
// preserve the current size. Use callback to apply non-trivial
// programmatic constraints.
IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL);

// Parameters stacks (shared)

// use NULL as a shortcut to push default font
IMGUI_API void          PushFont(ImFont* font);
IMGUI_API void          PopFont();
// retrieve style color as stored in ImGuiStyle structure. use to feed
// back into PushStyleColor(), otherwise use GetColorU32() to get
// style color with style alpha baked in.
IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);
// get current font
IMGUI_API ImFont*       GetFont();
// get current font size (= height in pixels) of current font with
// current scale applied
IMGUI_API float         GetFontSize();
// get UV coordinate for a while pixel, useful to draw custom shapes
// via the ImDrawList API
IMGUI_API ImVec2        GetFontTexUvWhitePixel();
// retrieve given style color with style alpha applied and optional
// extra alpha multiplier
IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);
// retrieve given color with style alpha applied
IMGUI_API ImU32         GetColorU32(const ImVec4& col);
// retrieve given color with style alpha applied
IMGUI_API ImU32         GetColorU32(ImU32 col);

// Widgets: Main

// - Most widgets return true when the value has been changed or when pressed/selected

IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
// <0 frame_padding uses default frame padding settings. 0 for no padding
IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));

// Widgets: Drags

// - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
// - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
// - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
// - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).

IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = NULL, float power = 1.0f);
IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = NULL);
IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);
IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);

// Widgets: Input with Keyboard

// - If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h
// - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.

IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
IMGUI_API bool          InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);
IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);
IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);

// Widgets: Data Plotting

IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));

// Drag and Drop

// [BETA API] API may evolve!

// call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);
// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);
// only call EndDragDropSource() if BeginDragDropSource() returns true!
IMGUI_API void          EndDragDropSource();
// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
IMGUI_API bool                  BeginDragDropTarget();
// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);
// only call EndDragDropTarget() if BeginDragDropTarget() returns true!
IMGUI_API void                  EndDragDropTarget();
// peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.
IMGUI_API const ImGuiPayload*   GetDragDropPayload();

// Miscellaneous Utilities

// this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
IMGUI_API ImDrawList*   GetBackgroundDrawList();
// this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
IMGUI_API ImDrawList*   GetForegroundDrawList();
// you may use this when creating your own ImDrawList instances.
IMGUI_API ImDrawListSharedData* GetDrawListSharedData();
// get a string corresponding to the enum value (for display, saving, etc.).
IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);
// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
IMGUI_API void          SetStateStorage(ImGuiStorage* storage);
IMGUI_API ImGuiStorage* GetStateStorage();
