// Tasks
//
//   Context creation and access
//   Main
//   Parameters stacks (shared)
//   Widgets: Main
//   Widgets: Data Plotting
//   Drag and Drop
//   Windows Utilities
//   Miscellaneous Utilities
//

// ------------------------------------------------------------------------------------------------------------------------

// Context creation and access

// Each context create its own ImFontAtlas by default. You may
// instance one yourself and pass it to CreateContext() to share a
// font atlas between imgui contexts.  All those functions are not
// reliant on the current context.
IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
IMGUI_API ImGuiContext* GetCurrentContext();
IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert);

// Main

// access the IO structure (mouse/keyboard/gamepad inputs, time,
// various configuration options/flags)
IMGUI_API ImGuiIO&      GetIO();
// access the Style structure (colors, sizes). Always use
// PushStyleCol(), PushStyleVar() to modify style mid-frame.
IMGUI_API ImGuiStyle&   GetStyle();
// start a new Dear ImGui frame, you can submit any command from this
// point until Render()/EndFrame().
IMGUI_API void          NewFrame();
// ends the Dear ImGui frame. automatically called by Render(), you
// likely don't need to call that yourself directly. If you don't need
// to render data (skipping rendering) you may call EndFrame() but
// you'll have wasted CPU already! If you don't need to render, better
// to not create any imgui windows and not call NewFrame() at all!
IMGUI_API void          EndFrame();
// ends the Dear ImGui frame, finalize the draw data. You can get call
// GetDrawData() to obtain it and run your rendering
// function. (Obsolete: this used to call
// io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your
// render function yourself.)
IMGUI_API void          Render();
// valid after Render() and until the next call to NewFrame(). this is
// what you have to render.
IMGUI_API ImDrawData*   GetDrawData();

// Windows Utilities

// "current window" = the window we are appending into while inside a
// Begin()/End() block. "next window" = next window we will Begin()
// into.
// get draw list associated to the current window, to append your own
// drawing primitives
IMGUI_API ImDrawList*   GetWindowDrawList();

// Prefer using SetNextXXX functions (before Begin) rather that SetXXX
// functions (after Begin).
//
// set next window size limits. use -1,-1 on either X/Y axis to
// preserve the current size. Use callback to apply non-trivial
// programmatic constraints.
IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL);

// Parameters stacks (shared)

// use NULL as a shortcut to push default font
IMGUI_API void          PushFont(ImFont* font);
IMGUI_API void          PopFont();
// retrieve style color as stored in ImGuiStyle structure. use to feed
// back into PushStyleColor(), otherwise use GetColorU32() to get
// style color with style alpha baked in.
IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);
// get current font
IMGUI_API ImFont*       GetFont();
// get current font size (= height in pixels) of current font with
// current scale applied
IMGUI_API float         GetFontSize();
// get UV coordinate for a while pixel, useful to draw custom shapes
// via the ImDrawList API
IMGUI_API ImVec2        GetFontTexUvWhitePixel();
// retrieve given style color with style alpha applied and optional
// extra alpha multiplier
IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);
// retrieve given color with style alpha applied
IMGUI_API ImU32         GetColorU32(const ImVec4& col);
// retrieve given color with style alpha applied
IMGUI_API ImU32         GetColorU32(ImU32 col);

// Widgets: Main

// - Most widgets return true when the value has been changed or when pressed/selected

IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
// <0 frame_padding uses default frame padding settings. 0 for no padding
IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));

// Widgets: Data Plotting

IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));

// Drag and Drop

// [BETA API] API may evolve!

// call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);
// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);
// only call EndDragDropSource() if BeginDragDropSource() returns true!
IMGUI_API void          EndDragDropSource();
// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
IMGUI_API bool                  BeginDragDropTarget();
// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);
// only call EndDragDropTarget() if BeginDragDropTarget() returns true!
IMGUI_API void                  EndDragDropTarget();
// peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.
IMGUI_API const ImGuiPayload*   GetDragDropPayload();

// Miscellaneous Utilities

// this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
IMGUI_API ImDrawList*   GetBackgroundDrawList();
// this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
IMGUI_API ImDrawList*   GetForegroundDrawList();
// you may use this when creating your own ImDrawList instances.
IMGUI_API ImDrawListSharedData* GetDrawListSharedData();
// get a string corresponding to the enum value (for display, saving, etc.).
IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);
// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
IMGUI_API void          SetStateStorage(ImGuiStorage* storage);
IMGUI_API ImGuiStorage* GetStateStorage();
